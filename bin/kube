#!/bin/zsh

# This list was generated by `kubectl help`
typeset -A subcommands=(
# Basic Commands (Beginner):
"create"         "Create a resource by filename or stdin"
"expose"         "Take a replication controller, service, deployment or pod and expose it as a new Kubernetes Service"
"run"            "Run a particular image on the cluster"
"run-container"  "Run a particular image on the cluster"
"set"            "Set specific features on objects"
# Basic Commands (Intermediate):
"get"            "Display one or many resources"
"explain"        "Documentation of resources"
"edit"           "Edit a resource on the server"
"delete"         "Delete resources by filenames, stdin, resources and names, or by resources and label selector"
# Deploy Commands:
"rollout"        "Manage the rollout of a resource"
"rolling-update" "Perform a rolling update of the given ReplicationController"
"rollingupdate"  "Perform a rolling update of the given ReplicationController"
"scale"          "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job"
"resize"         "Set a new size for a Deployment, ReplicaSet, Replication Controller, or Job"
"autoscale"      "Auto-scale a Deployment, ReplicaSet, or ReplicationController"
# Cluster Management Commands:
"certificate"    "Modify certificate resources."
"cluster-info"   "Display cluster info"
"clusterinfo"    "Display cluster info"
"top"            "Display Resource (CPU/Memory/Storage) usage."
"cordon"         "Mark node as unschedulable"
"uncordon"       "Mark node as schedulable"
"drain"          "Drain node in preparation for maintenance"
"taint"          "Update the taints on one or more nodes"
# Troubleshooting and Debugging Commands:
"describe"       "Show details of a specific resource or group of resources"
"logs"           "Print the logs for a container in a pod"
"attach"         "Attach to a running container"
"exec"           "Execute a command in a container"
"port-forward"   "Forward one or more local ports to a pod"
"proxy"          "Run a proxy to the Kubernetes API server"
"cp"             "Copy files and directories to and from containers."
"auth"           "Inspect authorization"
# Advanced Commands:
"apply"          "Apply a configuration to a resource by filename or stdin"
"patch"          "Update field(s) of a resource using strategic merge patch"
"replace"        "Replace a resource by filename or stdin"
"update"         "Replace a resource by filename or stdin"
"convert"        "Convert config files between different API versions"
# Settings Commands:
"label"          "Update the labels on a resource"
"annotate"       "Update the annotations on a resource"
"completion"     "Output shell completion code for the specified shell (bash or zsh)"
# Other Commands:
"api-versions"   "Print the supported API versions on the server, in the form of "group/version""
"config"         "Modify kubeconfig files"
"help"           "Help about any command"
"plugin"         "Runs a command-line plugin"
"version"        "Print the client and server version information"
)

typeset -A extcommands=(
"ssh" "Alias for 'exec -it'"
)

function main() {
    local arg="${1:?too few arguments}"
    shift

    # Search from original kubectl commands
    if (( $+subcommands[$arg] )); then
        kubectl "$arg" "$@"
        return $status
    fi

    # e.g. kube kubectl get pods
    if [[ $arg == "kubectl" ]]; then
        kubectl "$@"
        return $status
    fi

    # Search from user-defined kube* commands
    local -a expand_subs=( ${^path}/{kube,kube-,kubectl-}$arg(N-.) )
    if (( $#expand_subs > 0 )); then
        $expand_subs[1]
        return $status
    fi

    # # Search from kubectl-* aliases
    # if (( ${(k)+aliases[kubectl-${arg}]} )); then
    #     echo ${(v)aliases[kubectl-${arg}]} | zsh
    #     return $?
    # fi

    # Search the original commands
    if (( $+extcommands[$arg] )); then
        case "$arg" in
            "ssh")
                kubectl exec -it "$1" bash &>/dev/null
                if (( $status != 0 )); then
                    kubectl exec -it "$1" sh
                    return $status
                fi
                return 0
                ;;
        esac
    fi

    # fuzzy_cmd=$(echo "${(kF)subcommands[@]}" | fuzzy_search "$arg")
    fuzzy_cmd=( ${(@f)"$(echo "${(kF)subcommands[@]}" | fuzzy_search "$arg")"} )
    case "$#fuzzy_cmd[@]" in
        0)
            # through
            ;;
        1)
            kubectl "$fuzzy_cmd[1]" "$@"
            return $status
            ;;
        *)
            echo "Similar commands are found. Which one?"
            printf "- %s\n" "${fuzzy_cmd[@]}"
            return 1
            ;;
    esac

    # Nothing to find
    echo "$arg: no such kubernetes command" >&2
    return 1
}

function fuzzy_search() {
    awk -v search_string="$1" '
BEGIN {
    # FS = " ";
}

{
    # calculates the degree of similarity
    if ( (1 - leven_dist($0, search_string) / (length($NF) + length(search_string))) * 100 >= 75 ) {
        # When the degree of similarity of search_string is greater than or equal to 70%,
        # to display the candidate path
        print $0
    }
}

# leven_dist returns the Levenshtein distance two text string
function leven_dist(a, b) {
    lena = length(a);
    lenb = length(b);

    if (lena == 0) {
        return lenb;
    }
    if (lenb == 0) {
        return lena;
    }

    for (row = 1; row <= lena; row++) {
        m[row,0] = row
    }
    for (col = 1; col <= lenb; col++) {
        m[0,col] = col
    }

    for (row = 1; row <= lena; row++) {
        ai = substr(a, row, 1)
        for (col = 1; col <= lenb; col++) {
            bi = substr(b, col, 1)
            if (ai == bi) {
                cost = 0
            } else {
                cost = 1
            }
            m[row,col] = min(m[row-1,col]+1, m[row,col-1]+1, m[row-1,col-1]+cost)
        }
    }

    return m[lena,lenb]
}

# min returns the smaller of x, y or z
function min(a, b, c) {
    result = a

    if (b < result) {
        result = b
    }

    if (c < result) {
        result = c
    }

    return result
}'
}

main "$@"
exit $status
